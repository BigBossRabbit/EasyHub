__d(function(g,_r,_i,_a,m,_e,d){"use strict";Object.defineProperty(_e,'__esModule',{value:!0}),Object.defineProperty(_e,"AbstractSimplePool",{enumerable:!0,get:function(){return R}}),Object.defineProperty(_e,"SimplePool",{enumerable:!0,get:function(){return x}}),Object.defineProperty(_e,"useWebSocketImplementation",{enumerable:!0,get:function(){return k}});var e=_r(d[0]),t=_r(d[1]),n=_r(d[2]),s=Symbol("verified");function i(e){if(!(e instanceof Object))return!1;if("number"!=typeof e.kind)return!1;if("string"!=typeof e.content)return!1;if("number"!=typeof e.created_at)return!1;if("string"!=typeof e.pubkey)return!1;if(!e.pubkey.match(/^[a-f0-9]{64}$/))return!1;if(!Array.isArray(e.tags))return!1;for(let t=0;t<e.tags.length;t++){let n=e.tags[t];if(!Array.isArray(n))return!1;for(let e=0;e<n.length;e++)if("string"!=typeof n[e])return!1}return!0}new TextDecoder("utf-8");var o=new TextEncoder;function r(e){try{-1===e.indexOf("://")&&(e="wss://"+e);let t=new URL(e);return"http:"===t.protocol?t.protocol="ws:":"https:"===t.protocol&&(t.protocol="wss:"),t.pathname=t.pathname.replace(/\/+/g,"/"),t.pathname.endsWith("/")&&(t.pathname=t.pathname.slice(0,-1)),("80"===t.port&&"ws:"===t.protocol||"443"===t.port&&"wss:"===t.protocol)&&(t.port=""),t.searchParams.sort(),t.hash="",t.toString()}catch(t){throw new Error(`Invalid URL: ${e}`)}}var c=class{next=null;prev=null;constructor(e){this.value=e}},a=class{constructor(){this.first=null,this.last=null}enqueue(e){const t=new c(e);return this.last?this.last===this.first?(this.last=t,this.last.prev=this.first,this.first.next=t):(t.prev=this.last,this.last.next=t,this.last=t):(this.first=t,this.last=t),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const e=this.first;return this.first=null,this.last=null,e.value}const e=this.first;return this.first=e.next,this.first&&(this.first.prev=null),e.value}};function u(e){if(!i(e))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content])}function l(e){let s=(0,n.sha256)(o.encode(u(e)));return(0,t.bytesToHex)(s)}var h=new class{generateSecretKey(){return e.schnorr.utils.randomPrivateKey()}getPublicKey(n){return(0,t.bytesToHex)(e.schnorr.getPublicKey(n))}finalizeEvent(n,i){const o=n;return o.pubkey=(0,t.bytesToHex)(e.schnorr.getPublicKey(i)),o.id=l(o),o.sig=(0,t.bytesToHex)(e.schnorr.sign(l(o),i)),o[s]=!0,o}verifyEvent(t){if("boolean"==typeof t[s])return t[s];const n=l(t);if(n!==t.id)return t[s]=!1,!1;try{const i=e.schnorr.verify(t.sig,n,t.pubkey);return t[s]=i,i}catch(e){return t[s]=!1,!1}}},f=(h.generateSecretKey,h.getPublicKey,h.finalizeEvent,h.verifyEvent);function p(e,t){if(e.ids&&-1===e.ids.indexOf(t.id))return!1;if(e.kinds&&-1===e.kinds.indexOf(t.kind))return!1;if(e.authors&&-1===e.authors.indexOf(t.pubkey))return!1;for(let n in e)if("#"===n[0]){let s=e[`#${n.slice(1)}`];if(s&&!t.tags.find(([e,t])=>e===n.slice(1)&&-1!==s.indexOf(t)))return!1}return!(e.since&&t.created_at<e.since)&&!(e.until&&t.created_at>e.until)}function b(e,t){for(let n=0;n<e.length;n++)if(p(e[n],t))return!0;return!1}function y(e,t){let n=t.length+3,s=e.indexOf(`"${t}":`)+n,i=e.slice(s).indexOf("\"")+s+1;return e.slice(i,i+64)}function v(e){let t=e.slice(0,22).indexOf("\"EVENT\"");if(-1===t)return null;let n=e.slice(t+7+1).indexOf("\"");if(-1===n)return null;let s=t+7+1+n,i=e.slice(s+1,80).indexOf("\"");if(-1===i)return null;let o=s+1+i;return e.slice(s+1,o)}function w(e,t){return{kind:22242,created_at:Math.floor(Date.now()/1e3),tags:[["relay",e],["challenge",t]],content:""}}async function T(){return new Promise((e,t)=>{try{if("undefined"!=typeof MessageChannel){const t=new MessageChannel,n=()=>{t.port1.removeEventListener("message",n),e()};t.port1.addEventListener("message",n),t.port2.postMessage(0),t.port1.start()}else"undefined"!=typeof setImmediate?setImmediate(e):"undefined"!=typeof setTimeout?setTimeout(e,0):e()}catch(e){console.error("during yield: ",e),t(e)}})}var E,P=e=>(e[s]=!0,!0),S=class extends Error{constructor(e,t){super(`Tried to send message '${e} on a closed connection to ${t}.`),this.name="SendingOnClosedConnection"}},O=class{_connected=!1;onclose=null;onnotice=e=>console.debug(`NOTICE from ${this.url}: ${e}`);baseEoseTimeout=4400;connectionTimeout=4400;publishTimeout=4400;pingFrequency=2e4;pingTimeout=2e4;resubscribeBackoff=[1e4,1e4,1e4,2e4,2e4,3e4,6e4];openSubs=new Map;reconnectAttempts=0;closedIntentionally=!1;openCountRequests=new Map;openEventPublishes=new Map;incomingMessageQueue=new a;queueRunning=!1;serial=0;constructor(e,t){this.url=r(e),this.verifyEvent=t.verifyEvent,this._WebSocket=t.websocketImplementation||WebSocket,this.enablePing=t.enablePing,this.enableReconnect=t.enableReconnect||!1}static async connect(e,t){const n=new O(e,t);return await n.connect(),n}closeAllSubscriptions(e){for(let[t,n]of this.openSubs)n.close(e);this.openSubs.clear();for(let[t,n]of this.openEventPublishes)n.reject(new Error(e));this.openEventPublishes.clear();for(let[t,n]of this.openCountRequests)n.reject(new Error(e));this.openCountRequests.clear()}get connected(){return this._connected}async reconnect(){const e=this.resubscribeBackoff[Math.min(this.reconnectAttempts,this.resubscribeBackoff.length-1)];this.reconnectAttempts++,this.reconnectTimeoutHandle=setTimeout(async()=>{try{await this.connect()}catch(e){}},e)}handleHardClose(e){this.pingTimeoutHandle&&(clearTimeout(this.pingTimeoutHandle),this.pingTimeoutHandle=void 0),this._connected=!1,this.connectionPromise=void 0;const t=this.closedIntentionally;this.closedIntentionally=!1,this.onclose?.(),this.enableReconnect&&!t?this.reconnect():this.closeAllSubscriptions(e)}async connect(){return this.connectionPromise||(this.challenge=void 0,this.authPromise=void 0,this.connectionPromise=new Promise((e,t)=>{this.connectionTimeoutHandle=setTimeout(()=>{t("connection timed out"),this.connectionPromise=void 0,this.onclose?.(),this.closeAllSubscriptions("relay connection timed out")},this.connectionTimeout);try{this.ws=new this._WebSocket(this.url)}catch(e){return clearTimeout(this.connectionTimeoutHandle),void t(e)}this.ws.onopen=()=>{this.reconnectTimeoutHandle&&(clearTimeout(this.reconnectTimeoutHandle),this.reconnectTimeoutHandle=void 0),clearTimeout(this.connectionTimeoutHandle),this._connected=!0,this.reconnectAttempts=0;for(const e of this.openSubs.values())e.eosed=!1,"function"==typeof this.enableReconnect&&(e.filters=this.enableReconnect(e.filters)),e.fire();this.enablePing&&this.pingpong(),e()},this.ws.onerror=e=>{clearTimeout(this.connectionTimeoutHandle),t(e.message||"websocket error"),this.handleHardClose("relay connection errored")},this.ws.onclose=e=>{clearTimeout(this.connectionTimeoutHandle),t(e.message||"websocket closed"),this.handleHardClose("relay connection closed")},this.ws.onmessage=this._onmessage.bind(this)})),this.connectionPromise}waitForPingPong(){return new Promise(e=>{this.ws.once("pong",()=>e(!0)),this.ws.ping()})}async waitForDummyReq(){return new Promise((e,t)=>{const n=this.subscribe([{ids:["a".repeat(64)]}],{oneose:()=>{n.close(),e(!0)},eoseTimeout:this.pingTimeout+1e3})})}async pingpong(){if(1===this.ws?.readyState){await Promise.any([this.ws&&this.ws.ping&&this.ws.once?this.waitForPingPong():this.waitForDummyReq(),new Promise(e=>setTimeout(()=>e(!1),this.pingTimeout))])?this.pingTimeoutHandle=setTimeout(()=>this.pingpong(),this.pingFrequency):this.ws?.readyState===this._WebSocket.OPEN&&this.ws?.close()}}async runQueue(){for(this.queueRunning=!0;!1!==this.handleNext();)await T();this.queueRunning=!1}handleNext(){const e=this.incomingMessageQueue.dequeue();if(!e)return!1;const t=v(e);if(t){const n=this.openSubs.get(t);if(!n)return;const s=y(e,"id"),i=n.alreadyHaveEvent?.(s);if(n.receivedEvent?.(this,s),i)return}try{let t=JSON.parse(e);switch(t[0]){case"EVENT":{const e=this.openSubs.get(t[1]),n=t[2];return void(this.verifyEvent(n)&&b(e.filters,n)&&e.onevent(n))}case"COUNT":{const e=t[1],n=t[2],s=this.openCountRequests.get(e);return void(s&&(s.resolve(n.count),this.openCountRequests.delete(e)))}case"EOSE":{const e=this.openSubs.get(t[1]);if(!e)return;return void e.receivedEose()}case"OK":{const e=t[1],n=t[2],s=t[3],i=this.openEventPublishes.get(e);return void(i&&(clearTimeout(i.timeout),n?i.resolve(s):i.reject(new Error(s)),this.openEventPublishes.delete(e)))}case"CLOSED":{const e=t[1],n=this.openSubs.get(e);if(!n)return;return n.closed=!0,void n.close(t[2])}case"NOTICE":return void this.onnotice(t[1]);case"AUTH":return void(this.challenge=t[1]);default:{const e=this.openSubs.get(t[1]);return void e?.oncustom?.(t)}}}catch(e){return}}async send(e){if(!this.connectionPromise)throw new S(e,this.url);this.connectionPromise.then(()=>{this.ws?.send(e)})}async auth(e){const t=this.challenge;if(!t)throw new Error("can't perform auth, no challenge was received");return this.authPromise||(this.authPromise=new Promise(async(n,s)=>{try{let i=await e(w(this.url,t)),o=setTimeout(()=>{let e=this.openEventPublishes.get(i.id);e&&(e.reject(new Error("auth timed out")),this.openEventPublishes.delete(i.id))},this.publishTimeout);this.openEventPublishes.set(i.id,{resolve:n,reject:s,timeout:o}),this.send('["AUTH",'+JSON.stringify(i)+"]")}catch(e){console.warn("subscribe auth function failed:",e)}})),this.authPromise}async publish(e){const t=new Promise((t,n)=>{const s=setTimeout(()=>{const t=this.openEventPublishes.get(e.id);t&&(t.reject(new Error("publish timed out")),this.openEventPublishes.delete(e.id))},this.publishTimeout);this.openEventPublishes.set(e.id,{resolve:t,reject:n,timeout:s})});return this.send('["EVENT",'+JSON.stringify(e)+"]"),t}async count(e,t){this.serial++;const n=t?.id||"count:"+this.serial,s=new Promise((e,t)=>{this.openCountRequests.set(n,{resolve:e,reject:t})});return this.send('["COUNT","'+n+'",'+JSON.stringify(e).substring(1)),s}subscribe(e,t){const n=this.prepareSubscription(e,t);return n.fire(),n}prepareSubscription(e,t){this.serial++;const n=t.id||(t.label?t.label+":":"sub:")+this.serial,s=new H(this,n,e,t);return this.openSubs.set(n,s),s}close(){this.closedIntentionally=!0,this.reconnectTimeoutHandle&&(clearTimeout(this.reconnectTimeoutHandle),this.reconnectTimeoutHandle=void 0),this.pingTimeoutHandle&&(clearTimeout(this.pingTimeoutHandle),this.pingTimeoutHandle=void 0),this.closeAllSubscriptions("relay connection closed by us"),this._connected=!1,this.onclose?.(),this.ws?.readyState===this._WebSocket.OPEN&&this.ws?.close()}_onmessage(e){this.incomingMessageQueue.enqueue(e.data),this.queueRunning||this.runQueue()}},H=class{closed=!1;eosed=!1;constructor(e,t,n,s){if(0===n.length)throw new Error("subscription can't be created with zero filters");this.relay=e,this.filters=n,this.id=t,this.alreadyHaveEvent=s.alreadyHaveEvent,this.receivedEvent=s.receivedEvent,this.eoseTimeout=s.eoseTimeout||e.baseEoseTimeout,this.oneose=s.oneose,this.onclose=s.onclose,this.onevent=s.onevent||(e=>{console.warn(`onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,e)})}fire(){this.relay.send('["REQ","'+this.id+'",'+JSON.stringify(this.filters).substring(1)),this.eoseTimeoutHandle=setTimeout(this.receivedEose.bind(this),this.eoseTimeout)}receivedEose(){this.eosed||(clearTimeout(this.eoseTimeoutHandle),this.eosed=!0,this.oneose?.())}close(e="closed by caller"){if(!this.closed&&this.relay.connected){try{this.relay.send('["CLOSE",'+JSON.stringify(this.id)+"]")}catch(e){if(!(e instanceof S))throw e}this.closed=!0}this.relay.openSubs.delete(this.id),this.onclose?.(e)}},R=class{relays=new Map;seenOn=new Map;trackRelays=!1;trustedRelayURLs=new Set;constructor(e){this.verifyEvent=e.verifyEvent,this._WebSocket=e.websocketImplementation,this.enablePing=e.enablePing,this.enableReconnect=e.enableReconnect}async ensureRelay(e,t){e=r(e);let n=this.relays.get(e);return n||(n=new O(e,{verifyEvent:this.trustedRelayURLs.has(e)?P:this.verifyEvent,websocketImplementation:this._WebSocket,enablePing:this.enablePing,enableReconnect:this.enableReconnect}),n.onclose=()=>{n&&!n.enableReconnect&&this.relays.delete(e)},t?.connectionTimeout&&(n.connectionTimeout=t.connectionTimeout),this.relays.set(e,n)),await n.connect(),n}close(e){e.map(r).forEach(e=>{this.relays.get(e)?.close(),this.relays.delete(e)})}subscribe(e,t,n){n.onauth=n.onauth||n.doauth;const s=[];for(let n=0;n<e.length;n++){const i=r(e[n]);s.find(e=>e.url===i)||s.push({url:i,filter:t})}return this.subscribeMap(s,n)}subscribeMany(e,t,n){n.onauth=n.onauth||n.doauth;const s=[],i=[];for(let n=0;n<e.length;n++){const o=r(e[n]);-1===i.indexOf(o)&&(i.push(o),s.push({url:o,filter:t}))}return this.subscribeMap(s,n)}subscribeMap(e,t){t.onauth=t.onauth||t.doauth;const n=new Map;for(const t of e){const{url:e,filter:s}=t;n.has(e)||n.set(e,[]),n.get(e).push(s)}const s=Array.from(n.entries()).map(([e,t])=>({url:e,filters:t}));this.trackRelays&&(t.receivedEvent=(e,t)=>{let n=this.seenOn.get(t);n||(n=new Set,this.seenOn.set(t,n)),n.add(e)});const i=new Set,o=[],r=[];let c=e=>{r[e]||(r[e]=!0,r.filter(e=>e).length===s.length&&(t.oneose?.(),c=()=>{}))};const a=[];let u=(e,n)=>{a[e]||(c(e),a[e]=n,a.filter(e=>e).length===s.length&&(t.onclose?.(a),u=()=>{}))};const l=e=>{if(t.alreadyHaveEvent?.(e))return!0;const n=i.has(e);return i.add(e),n},h=Promise.all(s.map(async({url:e,filters:n},s)=>{let i;try{i=await this.ensureRelay(e,{connectionTimeout:t.maxWait?Math.max(.8*t.maxWait,t.maxWait-1e3):void 0})}catch(e){return void u(s,e?.message||String(e))}let r=i.subscribe(n,{...t,oneose:()=>c(s),onclose:e=>{e.startsWith("auth-required: ")&&t.onauth?i.auth(t.onauth).then(()=>{i.subscribe(n,{...t,oneose:()=>c(s),onclose:e=>{u(s,e)},alreadyHaveEvent:l,eoseTimeout:t.maxWait})}).catch(e=>{u(s,`auth was required and attempted, but failed with: ${e}`)}):u(s,e)},alreadyHaveEvent:l,eoseTimeout:t.maxWait});o.push(r)}));return{async close(e){await h,o.forEach(t=>{t.close(e)})}}}subscribeEose(e,t,n){n.onauth=n.onauth||n.doauth;const s=this.subscribe(e,t,{...n,oneose(){s.close("closed automatically on eose")}});return s}subscribeManyEose(e,t,n){n.onauth=n.onauth||n.doauth;const s=this.subscribeMany(e,t,{...n,oneose(){s.close("closed automatically on eose")}});return s}async querySync(e,t,n){return new Promise(async s=>{const i=[];this.subscribeEose(e,t,{...n,onevent(e){i.push(e)},onclose(e){s(i)}})})}async get(e,t,n){t.limit=1;const s=await this.querySync(e,t,n);return s.sort((e,t)=>t.created_at-e.created_at),s[0]||null}publish(e,t,n){return e.map(r).map(async(e,s,i)=>{if(i.indexOf(e)!==s)return Promise.reject("duplicate url");let o=await this.ensureRelay(e);return o.publish(t).catch(async e=>{if(e instanceof Error&&e.message.startsWith("auth-required: ")&&n?.onauth)return await o.auth(n.onauth),o.publish(t);throw e}).then(e=>{if(this.trackRelays){let e=this.seenOn.get(t.id);e||(e=new Set,this.seenOn.set(t.id,e)),e.add(o)}return e})})}listConnectionStatus(){const e=new Map;return this.relays.forEach((t,n)=>e.set(n,t.connected)),e}destroy(){this.relays.forEach(e=>e.close()),this.relays=new Map}};try{E=WebSocket}catch{}function k(e){E=e}var x=class extends R{constructor(e){super({verifyEvent:f,websocketImplementation:E,...e})}}},1274,[1205,1218,1220]);